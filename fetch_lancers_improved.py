#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import asyncio
import aiohttp
import json
import re
import os
import openpyxl
from pathlib import Path
from typing import List
from openpyxl.utils import get_column_letter
from datetime import datetime
from playwright.async_api import async_playwright

# ====== Áí∞Â¢ÉË®≠ÂÆö ======
EXCEL_PATH = r"C:\Users\SUZUKI Natsumi\Ê†™Âºè‰ºöÁ§æReySolid\„ÄêB„ÄëIT-Solution@ReySolid - Ê°à‰ª∂ÁÆ°ÁêÜ - „Éâ„Ç≠„É•„É°„É≥„Éà\Ê°à‰ª∂ÁÆ°ÁêÜ\Ê°à‰ª∂ÊÉÖÂ†±.xlsx"
LANCERS_SEARCH_URL = "https://www.lancers.jp/work/search/system?budget_from=&budget_to=&work_rank%5B%5D=&work_rank%5B%5D=&work_rank%5B%5D=&keyword=&sort=work_post_date"
MAX_JOBS_TO_FETCH = 100
HEADLESS_MODE = True

# „Åæ„Åü„ÅØÂãïÁöÑ„Å´ÈÅ∏Êäû
def get_excel_path():
    paths = [
        r"C:\Users\SUZUKI Natsumi\Ê†™Âºè‰ºöÁ§æReySolid\„ÄêB„ÄëIT-Solution@ReySolid - Ê°à‰ª∂ÁÆ°ÁêÜ - „Éâ„Ç≠„É•„É°„É≥„Éà\Ê°à‰ª∂ÁÆ°ÁêÜ\Ê°à‰ª∂ÊÉÖÂ†±.xlsx",
        r"C:\Users\SUZUKI Natsumi\OneDrive - Ê†™Âºè‰ºöÁ§æReySolid\Ê°à‰ª∂ÊÉÖÂ†±.xlsx"
    ]
    
    for path in paths:
        if os.path.exists(path):
            print(f"üìä ‰ΩøÁî®„Åô„ÇãExcel„Éï„Ç°„Ç§„É´: {path}")
            # „Éï„Ç°„Ç§„É´„ÅÆÊõ¥Êñ∞Êó•ÊôÇ„ÇíË°®Á§∫
            mtime = datetime.fromtimestamp(os.path.getmtime(path))
            print(f"   ÊúÄÁµÇÊõ¥Êñ∞: {mtime}")
            return path
    
    return paths[0]  # „Éá„Éï„Ç©„É´„Éà

EXCEL_PATH = get_excel_path()


# ÂºäÁ§æ„Çπ„Ç≠„É´„Çª„ÉÉ„ÉàÔºàÊ§úÁ¥¢„ÉØ„Éº„ÉâÂÑ™ÂÖàÁâàÔºâ
COMPANY_SKILLS = {
    "Ë∂ÖÈ´òÂÑ™ÂÖàÂ∫¶": ["AI", "GPT", "ChatGPT", "Python", "API", "Django", "Next.js","React","TypeScript", "Ê©üÊ¢∞Â≠¶Áøí"],
    "È´òÂÑ™ÂÖàÂ∫¶": ["bot", "Talend", "Java", "„Çπ„Éû„Éõ„Ç¢„Éó„É™", "„É¢„Éê„Ç§„É´ÈñãÁô∫", "‰∫∫Â∑•Áü•ËÉΩ"],
    "‰∏≠ÂÑ™ÂÖàÂ∫¶": ["ÂäπÁéáÂåñ", "„ÉÑ„Éº„É´", "ÈñãÁô∫", "„Ç∑„Çπ„ÉÜ„É†ÈñãÁô∫", "React", "Node.js", "Ëá™ÂãïÂåñ", "„Çπ„ÇØ„É¨„Ç§„Éî„É≥„Ç∞"],
    "‰ΩéÂÑ™ÂÖàÂ∫¶": ["PostgreSQL", "MySQL", "Á§æÂÜÖ„ÉÑ„Éº„É´", "Ê•≠ÂãôÊîπÂñÑ", "„Ç¢„Éó„É™", "„Çµ„Ç§„Éà", "ÁÆ°ÁêÜ"],
    "ÊúÄ‰ΩéÂÑ™ÂÖàÂ∫¶": ["Render", "„É≠„É™„ÉÉ„Éù„ÉÉ„Éó", "WordPress", "PHP"]
}

# Èô§Â§ñ„Ç≠„Éº„ÉØ„Éº„Éâ
EXCLUDE_KEYWORDS = [
    "Ê±Ç‰∫∫", "Êé°Áî®", "Ëª¢ËÅ∑", "Ê≠£Á§æÂì°", "„Ç¢„É´„Éê„Ç§„Éà", "Ê¥æÈÅ£",
    "„Ç≥„É≥„Éö", "„Ç≥„É≥„Éö„ÉÜ„Ç£„Ç∑„Éß„É≥", "„Ç≥„É≥„ÉÜ„Çπ„Éà",
    "ÂãüÈõÜÁµÇ‰∫Ü", "ÁµÇ‰∫Ü", "Á∑†Âàá", "CAD",
    '„Éá„Ç∂„Ç§„É≥', '„Ç§„É©„Çπ„Éà', '„É≠„Ç¥', 'ÂãïÁîªÁ∑®ÈõÜ', 'ÂÜôÁúü', 'ÊíÆÂΩ±', 'Photoshop',
    'Illustrator', 'After Effects', 'Premiere', '„Ç∞„É©„Éï„Ç£„ÉÉ„ÇØ', 'UI/UX',
    'XD', 'Sketch', 'Canva', '„Éê„Éä„Éº', '„ÉÅ„É©„Ç∑', '„Éù„Çπ„Çø„Éº',
    'Ê±Ç‰∫∫', 'Êé°Áî®', '„É™„ÇØ„É´„Éº„Éà', '„Çπ„Ç´„Ç¶„Éà', '‰∫∫Êùê', '„Ç≥„É≥„Éö', '„Ç≥„É≥„ÉÜ„Çπ„Éà',
    'Êá∏Ë≥û', 'ÂøúÂãüËÄÖÂ§öÊï∞', 'ÈÅ∏ËÄÉ', 'ÂØ©Êüª', '„É©„Ç§„ÉÜ„Ç£„É≥„Ç∞', 'Ë®ò‰∫ã‰ΩúÊàê', '„Ç≤„Éº„É†',
    '„Éñ„É≠„Ç∞Ë®ò‰∫ã', 'SEOË®ò‰∫ã', '„Ç≥„Éî„Éº„É©„Ç§„ÉÜ„Ç£„É≥„Ç∞', '„Ç∑„Éä„É™„Ç™', 'ËÑöÊú¨',
    'ÁøªË®≥', 'ÈÄöË®≥', '„Ç¢„É≥„Ç±„Éº„Éà', '„É¢„Éã„Çø„Éº', '„É¨„Éì„É•„Éº',
    '„ÉÜ„É¨„Ç¢„Éù', 'Âñ∂Ê•≠', '„Ç´„Çπ„Çø„Éû„Éº„Çµ„Éù„Éº„Éà', '„Çµ„Éù„Éº„ÉàÊ•≠Âãô', '‰∫ãÂãô',
    'ÁµåÁêÜ', 'ÁßòÊõ∏', '„Ç¢„Ç∑„Çπ„Çø„É≥„Éà', 'ÂÜÖËÅ∑', 'Á∞°Âçò‰ΩúÊ•≠', 'ËªΩ‰ΩúÊ•≠'

]

# ====== Excel „Éò„É´„ÉëÔºà„ÇØ„É©„ÇπÂ§ñÔºâ ======
def _format_skill_matches_compact_for_excel(skill_matches: List[dict]) -> str:
    if not skill_matches:
        return ""
    ultra = [m.get("skill") for m in skill_matches if m.get("priority") == "Ë∂ÖÈ´òÂÑ™ÂÖàÂ∫¶"]
    high  = [m.get("skill") for m in skill_matches if m.get("priority") == "È´òÂÑ™ÂÖàÂ∫¶"]
    mid   = [m.get("skill") for m in skill_matches if m.get("priority") == "‰∏≠ÂÑ™ÂÖàÂ∫¶"]
    low   = [m.get("skill") for m in skill_matches if m.get("priority") == "‰ΩéÂÑ™ÂÖàÂ∫¶"]
    lowst = [m.get("skill") for m in skill_matches if m.get("priority") == "ÊúÄ‰ΩéÂÑ™ÂÖàÂ∫¶"]
    parts = []
    if ultra: parts.append("üî•" + ",".join(ultra[:2]))
    if high:  parts.append("‚òÖ" + ",".join(high[:2]))
    if mid:   parts.append("‚óÜ" + ",".join(mid[:2]))
    if low:   parts.append("‚óá" + ",".join(low[:1]))
    if lowst: parts.append("‚óã" + ",".join(lowst[:1]))
    s = " ".join(parts)
    return (s[:97] + "...") if len(s) > 100 else s

def _autosize_columns(ws):
    for col in ws.columns:
        max_len = 0
        col_letter = get_column_letter(col[0].column)
        for cell in col:
            v = str(cell.value) if cell.value is not None else ""
            max_len = max(max_len, len(v))
        ws.column_dimensions[col_letter].width = min(max(12, max_len + 2), 60)

def _ensure_book_and_sheets(path: Path):
    if not path.exists():
        wb = openpyxl.Workbook()
        ws = wb.active
        ws.title = "„É©„É≥„Çµ„Éº„Ç∫"
        # „Ç∑„É≥„Éó„É´„Å™„Éò„ÉÉ„ÉÄ„ÉºÊßãÊàê„Å´Â§âÊõ¥
        ws.append([
            "ÂèñÂæóÊó•ÊôÇ",
            "„Çø„Ç§„Éà„É´", 
            "„Ç´„ÉÜ„Ç¥„É™",
            "‰æ°Ê†º",
            "Á∑†Âàá",
            "URL",
            "ÂÑ™ÂÖàÂ∫¶„Çπ„Ç≥„Ç¢",
            "„Çπ„Ç≠„É´Ê¶ÇË¶Å"
        ])
        stat = wb.create_sheet("Áµ±Ë®à")
        stat.append(["timestamp","count","type","skill_match_rate","no_skill_match","multi_skill_match","high_priority"])
        wb.save(path)
    else:
        wb = openpyxl.load_workbook(path)
        if "„É©„É≥„Çµ„Éº„Ç∫" not in wb.sheetnames:
            ws = wb.create_sheet("„É©„É≥„Çµ„Éº„Ç∫")
            ws.append([
                "ÂèñÂæóÊó•ÊôÇ",
                "„Çø„Ç§„Éà„É´",
                "„Ç´„ÉÜ„Ç¥„É™", 
                "‰æ°Ê†º",
                "Á∑†Âàá",
                "URL",
                "ÂÑ™ÂÖàÂ∫¶„Çπ„Ç≥„Ç¢",
                "„Çπ„Ç≠„É´Ê¶ÇË¶Å"
            ])
        if "Áµ±Ë®à" not in wb.sheetnames:
            stat = wb.create_sheet("Áµ±Ë®à")
            stat.append(["timestamp","count","type","skill_match_rate","no_skill_match","multi_skill_match","high_priority"])
    return wb

def append_jobs_to_excel(data: dict, excel_path: str = EXCEL_PATH, dedupe_by_url: bool = True):
    try:
        path = Path(excel_path)
        wb = _ensure_book_and_sheets(path)
        ws = wb["„É©„É≥„Çµ„Éº„Ç∫"]
        stat = wb["Áµ±Ë®à"]

        existing_urls = set()
        if dedupe_by_url:
            for row in ws.iter_rows(min_row=2, values_only=True):
                if row and len(row) >= 6 and row[5]:  # URLÂàó„ÅØ6Áï™ÁõÆ
                    existing_urls.add(row[5])

        now_str = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        new_rows = 0
        
        for job in data.get("jobs", []):
            url = job.get("link") or ""
            if dedupe_by_url and url in existing_urls:
                continue
                
            # „Éò„ÉÉ„ÉÄ„Éº„Å®Âêå„ÅòÈ†ÜÂ∫è„ÅßËøΩË®ò
            ws.append([
                now_str,                    # ÂèñÂæóÊó•ÊôÇ
                job.get("title",""),        # „Çø„Ç§„Éà„É´
                job.get("category",""),     # „Ç´„ÉÜ„Ç¥„É™„Éº
                job.get("price",""),        # ‰æ°Ê†º
                job.get("deadline",""),     # Á∑†Âàá
                url,                        # URL
                job.get("priority_score",""), # ÂÑ™ÂÖàÂ∫¶„Çπ„Ç≥„Ç¢
                _format_skill_matches_compact_for_excel(job.get("skill_matches", []))  # „Çπ„Ç≠„É´Ê¶ÇË¶Å
            ])
            
            last = ws.max_row
            # URL„Å´„Éè„Ç§„Éë„Éº„É™„É≥„ÇØË®≠ÂÆöÔºà6ÂàóÁõÆÔºâ
            if url:
                ws.cell(row=last, column=6).hyperlink = url
                ws.cell(row=last, column=6).style = "Hyperlink"
            
            new_rows += 1

        # Áµ±Ë®à„Ç∑„Éº„Éà„ÅÆÊõ¥Êñ∞
        dist = data.get("skill_distribution", {})
        stat.append([
            data.get("timestamp", now_str),
            data.get("count", 0),
            data.get("type", ""),
            dist.get("skill_match_rate",""),
            dist.get("no_skill_match",""),
            dist.get("multi_skill_match",""),
            dist.get("high_priority",""),
        ])

        _autosize_columns(ws)
        _autosize_columns(stat)
        wb.save(path)
        print(f"üìä ExcelÂá∫Âäõ: {path} | Ê°à‰ª∂ {new_rows}‰ª∂„ÇíËøΩË®òÔºàÁµ±Ë®à1Ë°åÔºâ")
        
    except PermissionError:
        print("‚ùå Excel„Éï„Ç°„Ç§„É´„ÅåÈñã„Åã„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇÈñâ„Åò„Å¶„Åã„ÇâÂÜçÂÆüË°å„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ")
    except Exception as e:
        print(f"‚ùå ExcelÂá∫Âäõ„Ç®„É©„Éº: {e}")

class CompleteJobsNotifier:
    def __init__(self):
        self.jobs_data = []
        self.seen_links = set()

    async def fetch_jobs(self):
        """ÂÖ®Ê°à‰ª∂„ÇíÂèñÂæóÔºà„Éï„Ç£„É´„Çø„É™„É≥„Ç∞ÊúÄÂ∞èÈôêÔºâ"""
        print("üöÄ LancersÂÖ®Ê°à‰ª∂ÂèñÂæó„ÇíÈñãÂßã...")

        async with async_playwright() as p:
            browser = await p.chromium.launch(headless=HEADLESS_MODE, slow_mo=300)
            try:
                context = await browser.new_context(
                    user_agent="Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36",
                    locale="ja-JP"
                )
                page = await context.new_page()

                print(f"üì° „Ç¢„ÇØ„Çª„Çπ‰∏≠: {LANCERS_SEARCH_URL}")
                response = await page.goto(LANCERS_SEARCH_URL, wait_until="domcontentloaded", timeout=60000)
                print(f"‚úÖ „Éö„Éº„Ç∏Ë™≠„ÅøËæº„ÅøÂÆå‰∫Ü („Çπ„ÉÜ„Éº„Çø„Çπ: {response.status})")

                await page.wait_for_timeout(5000)
                await self.scroll_and_load_more(page)

                job_elements = await page.query_selector_all("a[href*='/work/detail/']")
                print(f"üìä {len(job_elements)} ÂÄã„ÅÆÊ°à‰ª∂ÂÄôË£ú„ÇíÁô∫Ë¶ã")

                all_jobs = []
                for element in job_elements:
                    if len(all_jobs) >= MAX_JOBS_TO_FETCH:
                        break
                    job_info = await self.extract_job_info(element, page)
                    if job_info and self.should_include_job_minimal(job_info):
                        all_jobs.append(job_info)
                        skill_info = self.format_skill_matches(job_info["skill_matches"])
                        print(f"üìù Ê°à‰ª∂ {len(all_jobs)}: {job_info['title'][:40]}... | {skill_info}")

                sorted_jobs = self.sort_by_skill_relevance(all_jobs)
                print(f"‚úÖ ÂÖ® {len(sorted_jobs)} ‰ª∂„ÅÆÊ°à‰ª∂„ÇíÂèñÂæó„Åó„Åæ„Åó„Åü")
                self.jobs_data = sorted_jobs
                return sorted_jobs

            except Exception as e:
                print(f"‚ùå „Ç®„É©„Éº: {e}")
                return []
            finally:
                await browser.close()

    async def scroll_and_load_more(self, page):
        try:
            for _ in range(5):
                await page.evaluate("window.scrollTo(0, document.body.scrollHeight)")
                await page.wait_for_timeout(2000)
            more_button = await page.query_selector(".more-button, .load-more, [class*='more']")
            if more_button:
                await more_button.click()
                await page.wait_for_timeout(3000)
            for _ in range(3):
                await page.evaluate("window.scrollTo(0, document.body.scrollHeight)")
                await page.wait_for_timeout(2000)
        except Exception as e:
            print(f"‚ö†Ô∏è „Çπ„ÇØ„É≠„Éº„É´Ë™≠„ÅøËæº„Åø„Ç®„É©„Éº: {e}")

    async def extract_job_info(self, element, page):
        try:
            title_text = await element.text_content()
            href = await element.get_attribute("href")
            if not title_text or not href:
                return None
            title = self.clean_title(title_text)
            if not title or len(title) < 5:
                return None
            if href.startswith("/"):
                href = "https://www.lancers.jp" + href
            if href in self.seen_links:
                return None
            self.seen_links.add(href)

            recruitment_info = await self.extract_recruitment_details(element)
            skill_matches = self.find_all_skill_matches(title)
            job_info = {
                "title": title,
                "link": href,
                "price": recruitment_info["price"],
                "deadline": recruitment_info["deadline"],
                "applicant_count": recruitment_info["applicant_count"],
                "recruitment_count": recruitment_info["recruitment_count"],
                "client_name": recruitment_info["client_name"],
                "status": recruitment_info["status"],
                "urgency": recruitment_info["urgency"],
                "category": recruitment_info["category"],
                "skill_matches": skill_matches,
                "skill_count": len(skill_matches),
                "priority_score": self.calculate_comprehensive_score(title, recruitment_info, skill_matches),
                "scraped_at": datetime.now().isoformat()
            }
            return job_info
        except Exception as e:
            print(f"‚ö†Ô∏è Ê°à‰ª∂ÊäΩÂá∫„Ç®„É©„Éº: {e}")
            return None

    def find_all_skill_matches(self, title):
        matches = []
        title_lower = title.lower()
        for priority, skills in COMPANY_SKILLS.items():
            for skill in skills:
                if skill.lower() in title_lower:
                    matches.append({"skill": skill, "priority": priority})
        additional_keywords = {
            "Ëá™ÂãïÂåñ": "‰∏≠ÂÑ™ÂÖàÂ∫¶",
            "„Çπ„ÇØ„É¨„Ç§„Éî„É≥„Ç∞": "‰∏≠ÂÑ™ÂÖàÂ∫¶", 
            "„Ç¢„Éó„É™": "‰∏≠ÂÑ™ÂÖàÂ∫¶",
            "„Çµ„Ç§„Éà": "‰ΩéÂÑ™ÂÖàÂ∫¶",
            "ÁÆ°ÁêÜ": "‰ΩéÂÑ™ÂÖàÂ∫¶",
            "„Ç≥„É≥„Çµ„É´": "‰∏≠ÂÑ™ÂÖàÂ∫¶",
            "Ai": "Ë∂ÖÈ´òÂÑ™ÂÖàÂ∫¶",
            "‰∫∫Â∑•Áü•ËÉΩ": "È´òÂÑ™ÂÖàÂ∫¶"
        }
        for keyword, priority in additional_keywords.items():
            if keyword.lower() in title_lower:
                matches.append({"skill": keyword, "priority": priority})
        seen_skills = set()
        unique_matches = []
        for m in matches:
            if m["skill"] not in seen_skills:
                unique_matches.append(m)
                seen_skills.add(m["skill"])
        return unique_matches

    def format_skill_matches(self, skill_matches):
        if not skill_matches:
            return "üîß „Çπ„Ç≠„É´„Çª„ÉÉ„Éà: „Å™„Åó"
        skills_by_priority = {}
        for m in skill_matches:
            p = m["priority"]
            skills_by_priority.setdefault(p, []).append(m["skill"])
        parts = []
        if "Ë∂ÖÈ´òÂÑ™ÂÖàÂ∫¶" in skills_by_priority: parts.append(f"üî•{', '.join(skills_by_priority['Ë∂ÖÈ´òÂÑ™ÂÖàÂ∫¶'])}")
        if "È´òÂÑ™ÂÖàÂ∫¶" in skills_by_priority:  parts.append(f"‚òÖ{', '.join(skills_by_priority['È´òÂÑ™ÂÖàÂ∫¶'])}")
        if "‰∏≠ÂÑ™ÂÖàÂ∫¶" in skills_by_priority:  parts.append(f"‚óÜ{', '.join(skills_by_priority['‰∏≠ÂÑ™ÂÖàÂ∫¶'])}")
        if "‰ΩéÂÑ™ÂÖàÂ∫¶" in skills_by_priority:  parts.append(f"‚óá{', '.join(skills_by_priority['‰ΩéÂÑ™ÂÖàÂ∫¶'])}")
        if "ÊúÄ‰ΩéÂÑ™ÂÖàÂ∫¶" in skills_by_priority: parts.append(f"‚óã{', '.join(skills_by_priority['ÊúÄ‰ΩéÂÑ™ÂÖàÂ∫¶'])}")
        return f"üîß „Çπ„Ç≠„É´„Çª„ÉÉ„Éà: {' | '.join(parts)}" if parts else "üîß „Çπ„Ç≠„É´„Çª„ÉÉ„Éà: „Å™„Åó"

    def format_skill_matches_compact(self, skill_matches: List[dict]) -> str:
        if not skill_matches:
            return "üîß „Çπ„Ç≠„É´„Çª„ÉÉ„Éà: „Å™„Åó"
        ultra = [m.get("skill") for m in skill_matches if m.get("priority") == "Ë∂ÖÈ´òÂÑ™ÂÖàÂ∫¶"]
        high  = [m.get("skill") for m in skill_matches if m.get("priority") == "È´òÂÑ™ÂÖàÂ∫¶"]
        mid   = [m.get("skill") for m in skill_matches if m.get("priority") == "‰∏≠ÂÑ™ÂÖàÂ∫¶"]
        low   = [m.get("skill") for m in skill_matches if m.get("priority") == "‰ΩéÂÑ™ÂÖàÂ∫¶"]
        lowst = [m.get("skill") for m in skill_matches if m.get("priority") == "ÊúÄ‰ΩéÂÑ™ÂÖàÂ∫¶"]
        parts = []
        if ultra: parts.append("üî•" + ",".join(ultra[:2]))
        if high:  parts.append("‚òÖ" + ",".join(high[:2]))
        if mid:   parts.append("‚óÜ" + ",".join(mid[:2]))
        if low:   parts.append("‚óá" + ",".join(low[:1]))
        if lowst: parts.append("‚óã" + ",".join(lowst[:1]))
        s = " ".join(parts) if parts else ""
        if len(s) > 100: s = s[:97] + "..."
        return f"üîß „Çπ„Ç≠„É´„Çª„ÉÉ„Éà: {s}" if s else "üîß „Çπ„Ç≠„É´„Çª„ÉÉ„Éà: „Å™„Åó"

    async def extract_recruitment_details(self, element):
        recruitment_info = {
            "price": "‰æ°Ê†ºÊÉÖÂ†±„Å™„Åó",
            "deadline": "ÊúüÈôêÊÉÖÂ†±„Å™„Åó", 
            "applicant_count": "0",
            "recruitment_count": "1",
            "client_name": "‰æùÈ†ºËÄÖÊÉÖÂ†±„Å™„Åó",
            "status": "ÂãüÈõÜ‰∏≠",
            "urgency": False,
            "category": "„Ç∑„Çπ„ÉÜ„É†ÈñãÁô∫"
        }
        try:
            parent = await element.evaluate_handle("el => el.closest('.c-media, .p-jobList__item, article, li')")
            if parent:
                price_elem = await parent.query_selector(".c-media__price, .price, .budget, [class*='price']")
                if price_elem:
                    price_text = await price_elem.text_content()
                    if price_text and "ÂÜÜ" in price_text:
                        recruitment_info["price"] = self.clean_price_text(price_text)
                deadline_elem = await parent.query_selector(".c-media__deadline, .deadline, [class*='deadline']")
                if deadline_elem:
                    deadline_text = await deadline_elem.text_content()
                    if deadline_text:
                        recruitment_info["deadline"] = deadline_text.strip()
                        if any(w in deadline_text for w in ["ÊÄ•Âãü", "Á∑äÊÄ•", "Âç≥Êó•", "Ëá≥ÊÄ•"]):
                            recruitment_info["urgency"] = True
                applicant_elem = await parent.query_selector(".c-media__applicant, .applicant, [class*='applicant']")
                if applicant_elem:
                    applicant_text = await applicant_elem.text_content()
                    if applicant_text:
                        numbers = re.findall(r'(\d+)', applicant_text)
                        if len(numbers) >= 2:
                            recruitment_info["applicant_count"] = numbers[0]
                            recruitment_info["recruitment_count"] = numbers[1]
        except:
            pass
        return recruitment_info

    def clean_title(self, title):
        if not title:
            return ""
        try:
            import unicodedata
            title = unicodedata.normalize('NFKC', title)
        except:
            pass
        title = re.sub(r'\s+', ' ', title.strip())
        title = re.sub(r'^(NEW\s*){1,}', '', title, flags=re.IGNORECASE)
        title = re.sub(r'^\d+ÂõûÁõÆ\s*', '', title)
        return title.strip()

    def clean_price_text(self, raw_price):
        if not raw_price:
            return "‰æ°Ê†ºÊÉÖÂ†±„Å™„Åó"
        try:
            import unicodedata
            raw_price = unicodedata.normalize('NFKC', raw_price)
        except:
            pass
        price = re.sub(r'\s+', ' ', raw_price.strip())
        price = re.sub(r'ÂÜÜ\s*/\s*', 'ÂÜÜ / ', price)
        return price

    def calculate_comprehensive_score(self, title, recruitment_info, skill_matches):
        score = 0
        title_lower = title.lower()
        for m in skill_matches:
            p = m["priority"]
            if p == "Ë∂ÖÈ´òÂÑ™ÂÖàÂ∫¶": score += 100
            elif p == "È´òÂÑ™ÂÖàÂ∫¶": score += 50
            elif p == "‰∏≠ÂÑ™ÂÖàÂ∫¶": score += 20
            elif p == "‰ΩéÂÑ™ÂÖàÂ∫¶": score += 10
            elif p == "ÊúÄ‰ΩéÂÑ™ÂÖàÂ∫¶": score += 5
        if len(skill_matches) >= 3: score += 50
        elif len(skill_matches) >= 2: score += 25
        elif len(skill_matches) >= 1: score += 10
        priority_keywords = {
            "chatgpt": 80, "python": 70, "api": 60, "ai": 60,
            "Ëá™ÂãïÂåñ": 40, "bot": 40, "ÂäπÁéáÂåñ": 30, "„ÉÑ„Éº„É´": 25, "ÈñãÁô∫": 20, "„Ç∑„Çπ„ÉÜ„É†": 15
        }
        for k, bonus in priority_keywords.items():
            if k in title_lower:
                score += bonus
        if recruitment_info["urgency"]:
            score += 15
        try:
            applicant_count = int(recruitment_info["applicant_count"])
            if applicant_count == 0: score += 10
            elif applicant_count <= 2: score += 5
        except:
            pass
        price_text = recruitment_info["price"]
        if "ÂÜÜ" in price_text:
            numbers = re.findall(r'(\d+,?\d*)', price_text.replace(',', ''))
            if numbers:
                try:
                    max_price = max([int(num.replace(',', '')) for num in numbers])
                    if max_price >= 500000: score += 15
                    elif max_price >= 100000: score += 8
                    elif max_price >= 50000:  score += 3
                except:
                    pass
        return score

    def should_include_job_minimal(self, job_info):
        title = job_info["title"]
        if not title or len(title.strip()) < 5:
            return False
        title_lower = title.lower()
        for keyword in EXCLUDE_KEYWORDS:
            if keyword.lower() in title_lower:
                return False
        status = job_info["status"]
        if any(w in status for w in ["ÂãüÈõÜÁµÇ‰∫Ü", "Á∑†Âàá", "ÁµÇ‰∫Ü", "ÂÆå‰∫Ü"]):
            return False
        if job_info["priority_score"] >= 10 or job_info["skill_count"] >= 1:
            return True
        priority_keywords = ["chatgpt", "python", "api", "ai", "Ëá™ÂãïÂåñ", "bot", "ÂäπÁéáÂåñ", "„ÉÑ„Éº„É´", "ÈñãÁô∫", "„Ç∑„Çπ„ÉÜ„É†"]
        if any(k in title_lower for k in priority_keywords):
            return True
        return False

    def sort_by_skill_relevance(self, jobs):
        def sort_key(job):
            base_score = job["priority_score"]
            if job["skill_count"] == 0:
                base_score -= 1000
            applicant_count = int(job["applicant_count"]) if job["applicant_count"].isdigit() else 999
            return (-base_score, -job["skill_count"], applicant_count, not job["urgency"], job["scraped_at"])
        return sorted(jobs, key=sort_key)

    def create_teams_payload(self, jobs):
        if not jobs:
            return {
                "@type": "MessageCard",
                "@context": "https://schema.org/extensions",
                "summary": "LancersÂÖ®Ê°à‰ª∂ÈÄöÁü•",
                "themeColor": "0078D4",
                "title": "üöÄ LancersÂÖ®Ê°à‰ª∂„É™„Çπ„Éà",
                "text": "üì≠ ÁèæÂú®Êù°‰ª∂„Å´Âêà„ÅÜÊ°à‰ª∂„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„Åß„Åó„Åü„ÄÇ"
            }
        MAX_CHARS = 25000
        header_text = f"ÁèæÂú®„ÅÆÂÖ®Ê°à‰ª∂„É™„Çπ„Éà„Åß„ÅôÔºà**{len(jobs)}‰ª∂**„ÇíÁô∫Ë¶ãÔºâ\n\n"
        footer_text = "\n\nüìã Ë©≥Á¥∞ÊÉÖÂ†±„ÅØJSON„Éï„Ç°„Ç§„É´„Åß„ÇÇÁ¢∫Ë™ç„Åß„Åç„Åæ„Åô„ÄÇ"
        available_chars = MAX_CHARS - len(header_text) - len(footer_text) - 500
        main_content = ""
        displayed_count = 0
        skipped_count = 0
        print(f"üìä TeamsË°®Á§∫Âà∂Èôê: {MAX_CHARS:,}ÊñáÂ≠ó„Åæ„ÅßÂà©Áî®ÂèØËÉΩ")
        for i, job in enumerate(jobs, 1):
            skill_info = self.format_skill_matches_compact(job["skill_matches"])
            job_text  = f"**{i}. {job['title']}**  \n"
            job_text += f"üí∞ {job['price']}  \n"
            if job['deadline'] != "ÊúüÈôêÊÉÖÂ†±„Å™„Åó" and len(job['deadline']) < 20:
                job_text += f"‚è∞ {job['deadline']}  \n"
            if job['applicant_count'] != "0":
                job_text += f"üë• ÂøúÂãü{job['applicant_count']}‰∫∫  \n"
            job_text += f"{skill_info}  \n"
            if job['urgency']:
                job_text += f"üö® ÊÄ•Âãü  \n"
            job_text += f"üîó [Ë©≥Á¥∞]({job['link']})  \n\n"
            if len(main_content) + len(job_text) > available_chars:
                skipped_count = len(jobs) - displayed_count
                print(f"üìù ÊñáÂ≠óÊï∞Âà∂Èôê„Å´„Çà„Çä {displayed_count}‰ª∂Ë°®Á§∫„ÄÅ{skipped_count}‰ª∂„Çπ„Ç≠„ÉÉ„Éó")
                break
            main_content += job_text
            displayed_count += 1
        final_text = header_text + main_content + (f"\nüìã ÊÆã„Çä{skipped_count}‰ª∂„ÅÆÊ°à‰ª∂„ÅØJSON„Éï„Ç°„Ç§„É´„ÅßÁ¢∫Ë™ç„Åß„Åç„Åæ„Åô„ÄÇ" if skipped_count > 0 else footer_text)
        actual_chars = len(final_text)
        print(f"üìä ÂÆüÈöõ„ÅÆÊñáÂ≠óÊï∞: {actual_chars:,}ÊñáÂ≠ó / {MAX_CHARS:,}ÊñáÂ≠ó ({actual_chars/MAX_CHARS*100:.1f}%)")
        print(f"üìä Ë°®Á§∫Ê°à‰ª∂Êï∞: {displayed_count}‰ª∂ / {len(jobs)}‰ª∂")
        return {
            "@type": "MessageCard",
            "@context": "https://schema.org/extensions",
            "summary": f"LancersÂÖ®Ê°à‰ª∂ {len(jobs)}‰ª∂",
            "themeColor": "0078D4",
            "title": f"üöÄ LancersÂÖ®Ê°à‰ª∂„É™„Çπ„Éà ({len(jobs)}‰ª∂Áô∫Ë¶ã / {displayed_count}‰ª∂Ë°®Á§∫) - {datetime.now().strftime('%Y/%m/%d %H:%M')}",
            "text": final_text,
            "potentialAction": [{
                "@type": "OpenUri",
                "name": "üîç Lancers„ÅßÊ°à‰ª∂„ÇíÊé¢„Åô",
                "targets": [{"os": "default", "uri": LANCERS_SEARCH_URL}]
            }]
        }

    async def send_to_teams(self, jobs):
        try:
            from dotenv import load_dotenv
            load_dotenv()
        except:
            pass
        webhook_url = os.getenv("TEAMS_WEBHOOK_URL")
        if not webhook_url:
            print("‚ùå Teams Webhook URL„ÅåË®≠ÂÆö„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì")
            return False

        payload = self.create_teams_payload(jobs)

        try:
            async with aiohttp.ClientSession() as session:
                print("üì§ Teams„Å´ÂÖ®Ê°à‰ª∂„É™„Çπ„Éà„ÇíÈÄÅ‰ø°‰∏≠...")
                async with session.post(
                    webhook_url,
                    json=payload,
                    headers={"Content-Type": "application/json"}
                ) as response:
                    if response.status == 200:
                        print("‚úÖ TeamsÈÄÅ‰ø°ÊàêÂäüÔºÅ")
                        return True
                    else:
                        print(f"‚ùå TeamsÈÄÅ‰ø°Â§±Êïó („Çπ„ÉÜ„Éº„Çø„Çπ: {response.status})")
                        return False
        except Exception as e:
            print(f"‚ùå TeamsÈÄÅ‰ø°„Ç®„É©„Éº: {e}")
            return False

    def save_data(self, jobs):
        timestamp = datetime.now()
        data = {
            "timestamp": timestamp.isoformat(),
            "count": len(jobs),
            "type": "ÂÖ®Ê°à‰ª∂„É™„Çπ„Éà",
            "skill_summary": self.create_skill_summary(jobs),
            "skill_distribution": self.create_skill_distribution(jobs),
            "jobs": jobs
        }
        filename = f"all_jobs_{timestamp.strftime('%Y%m%d_%H%M')}.json"
        with open(filename, "w", encoding="utf-8") as f:
            json.dump(data, f, ensure_ascii=False, indent=2)
        print(f"üíæ ÂÖ®Ê°à‰ª∂„Éá„Éº„Çø„Çí‰øùÂ≠ò: {filename}")

    def create_skill_summary(self, jobs):
        skill_counts = {}
        for job in jobs:
            for match in job["skill_matches"]:
                skill = match["skill"]
                skill_counts[skill] = skill_counts.get(skill, 0) + 1
        return dict(sorted(skill_counts.items(), key=lambda x: x[1], reverse=True))

    def create_skill_distribution(self, jobs):
        total_jobs = len(jobs)
        no_skill_jobs = len([job for job in jobs if job["skill_count"] == 0])
        multi_skill_jobs = len([job for job in jobs if job["skill_count"] >= 2])
        high_priority_jobs = len([job for job in jobs if job["priority_score"] >= 10])
        return {
            "total_jobs": total_jobs,
            "no_skill_match": no_skill_jobs,
            "multi_skill_match": multi_skill_jobs,
            "high_priority": high_priority_jobs,
            "skill_match_rate": round((total_jobs - no_skill_jobs) / total_jobs * 100, 1) if total_jobs > 0 else 0
        }


# ====== „Ç®„É≥„Éà„É™„Éù„Ç§„É≥„Éà ======
async def main():
    print("=" * 70)
    print("ü§ñ LancersÂÖ®Ê°à‰ª∂ÂèñÂæó„Ç∑„Çπ„ÉÜ„É†ÔºàTeams28KBÊúÄÂ§ßÊ¥ªÁî®ÁâàÔºâ")
    print("=" * 70)

    notifier = CompleteJobsNotifier()
    jobs = await notifier.fetch_jobs()

    if jobs:
        # JSON‰øùÂ≠ò
        notifier.save_data(jobs)

        # Excel„Å´„ÇÇËøΩË®ò
        excel_data = {
            "timestamp": datetime.now().isoformat(),
            "count": len(jobs),
            "type": "ÂÖ®Ê°à‰ª∂„É™„Çπ„Éà",
            "skill_summary": notifier.create_skill_summary(jobs),
            "skill_distribution": notifier.create_skill_distribution(jobs),
            "jobs": jobs
        }
        append_jobs_to_excel(excel_data, EXCEL_PATH, dedupe_by_url=True)

        # TeamsÈÄÅ‰ø°
        teams_success = await notifier.send_to_teams(jobs)

        print("\n" + "=" * 70)
        print("üìä ÂÆüË°åÁµêÊûú:")
        print("=" * 70)
        print(f"‚úÖ ÂÖ®Ê°à‰ª∂Êï∞: {len(jobs)}‰ª∂")
        print(f"üì§ TeamsÈÄÅ‰ø°: {'ÊàêÂäü' if teams_success else 'Â§±Êïó'}")
        print(f"üíæ „Éá„Éº„Çø‰øùÂ≠ò: ÂÆå‰∫Ü")

        skill_summary = notifier.create_skill_summary(jobs)
        skill_distribution = notifier.create_skill_distribution(jobs)
        print(f"\nüîß „Çπ„Ç≠„É´Âà•„Éû„ÉÉ„ÉÅ‰ª∂Êï∞Ôºà‰∏ä‰Ωç10‰ΩçÔºâ:")
        for skill, count in list(skill_summary.items())[:10]:
            print(f"   {skill}: {count}‰ª∂")

        print(f"\nüìà „Çπ„Ç≠„É´ÂàÜÂ∏É:")
        print(f"   „Çπ„Ç≠„É´„Éû„ÉÉ„ÉÅÁéá: {skill_distribution['skill_match_rate']}%")
        print(f"   Ë§áÊï∞„Çπ„Ç≠„É´„Éû„ÉÉ„ÉÅ: {skill_distribution['multi_skill_match']}‰ª∂")
        print(f"   È´òÂÑ™ÂÖàÂ∫¶Ê°à‰ª∂: {skill_distribution['high_priority']}‰ª∂")
        print(f"   „Çπ„Ç≠„É´„Éû„ÉÉ„ÉÅ„Å™„Åó: {skill_distribution['no_skill_match']}‰ª∂")
    else:
        print("‚ùå Ê°à‰ª∂„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„Åß„Åó„Åü")

if __name__ == "__main__":
    asyncio.run(main())
